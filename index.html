<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Grid — Snap, Shapes</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden}
    canvas{display:block;width:100%;height:100%;background:#ffffff;touch-action:none}
    #controls {
      position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:20
    }
    .btn {
      width:40px;height:40px;display:flex;align-items:center;justify-content:center;background:#fff;border:1px solid #ccc;border-radius:8px;cursor:pointer;font-size:18px;box-shadow:0 3px 8px rgba(0,0,0,0.08);user-select:none
    }

    #popup {
      position:fixed;inset:0;background:rgba(0,0,0,0.35);display:none;align-items:center;justify-content:center;z-index:30;
    }
    .modal {
      background:#fff;padding:18px;border-radius:10px;max-width:520px;width:90%;box-shadow:0 8px 30px rgba(0,0,0,0.2);position:relative;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#111;
    }
    .modal h2{margin:0 0 8px 0}
    .closeX{position:absolute;right:12px;top:8px;cursor:pointer;font-size:20px}
    #errToast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#fff;padding:8px 12px;border-radius:8px;border:1px solid #f44336;color:#f44336;display:none;z-index:60}
    #coordBox{position:fixed;right:12px;bottom:12px;padding:6px 8px;background:rgba(255,255,255,0.9);border:1px solid #eee;border-radius:8px;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;font-size:13px}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="controls">
    <div id="infoBtn" class="btn">ℹ️</div>
  </div>

  <!-- Info Modal -->
  <div id="popup"><div class="modal" id="infoModal">
    <div id="closeInfo" class="closeX">❌</div>
    <h2>Controls & Instructions</h2>
    <div>
      <ul>
        <li>Left click / tap: place a point (snaps to nearest grid intersection)</li>
        <li>Alternating players: Player 1 then Player 2, continuously</li>
        <li>Can't place where a ball already exists</li>
        <li>Right-click + drag or touch swipe: pan the grid</li>
        <li>Mouse wheel or + / - keys: zoom (balls scale with zoom)</li>
        <li>Ctrl+Z: Undo, Ctrl+Y: Redo</li>
        <li>R: Reset view</li>
      </ul>
    </div>
  </div></div>

  <div id="errToast">Importing error.</div>
  <div id="coordBox">x: 0.00, y: 0.00, zoom: 1.00</div>

<script>


        
(() => {
  // === CANVAS & CONTEXT INITIALIZATION ===
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // === UI ELEMENT REFERENCES ===
  const infoBtn = document.getElementById('infoBtn');
  const popup = document.getElementById('popup');
  const closeInfo = document.getElementById('closeInfo');
  const errToast = document.getElementById('errToast');
  const coordBox = document.getElementById('coordBox');

  // === RESPONSIVE RESIZING FUNCTION ===
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // === GRID CONFIGURATION ===
  const baseGridPx = 40; // each grid unit equals 40 pixels
  let scale = 1.0; // zoom scale
  let camera = { x: 0, y: 0 }; // camera center in world coordinates
  let size = 0.5

  // === GAME STATE VARIABLES ===
  let counter = 0; // increases each time a point is placed (or when a captured-shape is saved as one move)
  const keys = {}; // keyboard state
  const speedUnitsPerSecond = 6; // camera pan speed
  const placedBalls = []; // all placed grid points
  const deadspace = []; //global array to collect enclosed empty coordinates, to prevent placing new points
  const enclosures = [];
  let nextPlayer = 1; // 1 or 2, determines next turn
  const undoStack = []; // history of moves for undo
  const redoStack = []; // history of undone moves for redo
  let hoverSnap = {x:0,y:0}; // hovered grid position (snapped)
  let isPanning = false; // panning flag
  let panLast = null; // last pan mouse position
  
  //scores

  // === PLAYER SETTINGS ===
  class Player {
    constructor(id, color, shape, score){ this.id = id; this.color = color; this.shape = shape; this.score = score }
  }
  // By default the game uses 2 players (but definitions for up to 4 exist)
  let playerCount = 2; // configurable later if desired (max 4)
  const players = []
  const defaultPlayers = {
    1: { color: '#ff0000', shape: 'circle', score:0 },
    2: { color: '#3b82f6', shape: 'square', score:0 },
    3: { color: '#00ff00', shape: 'triangle', score:0 },
    4: { color: '#7f00ff', shape: 'pentagon', score:0 }
  };
  for(let i=1;i<=4;i++) players.push(new Player(i, defaultPlayers[i].color, defaultPlayers[i].shape, defaultPlayers[i].score));

  updateCurrentPlayer()
  // === COORDINATE CONVERSION FUNCTIONS ===
  function worldToScreen(wx, wy){
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    return { x: cx + (wx - camera.x) * baseGridPx * scale, y: cy - (wy - camera.y) * baseGridPx * scale };
  }
  function screenToWorld(sx, sy){
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    return { x: camera.x + (sx - cx) / (baseGridPx * scale), y: camera.y - (sy - cy) / (baseGridPx * scale) };
  }

  // === DRAWING GRID ===
  function drawGrid(){
    const w = canvas.clientWidth; const h = canvas.clientHeight;
    const halfWUnits = (w/2) / (baseGridPx * scale);
    const halfHUnits = (h/2) / (baseGridPx * scale);
    const left = Math.floor(camera.x - halfWUnits) - 2;
    const right = Math.ceil(camera.x + halfWUnits) + 2;
    const bottom = Math.floor(camera.y - halfHUnits) - 2;
    const top = Math.ceil(camera.y + halfHUnits) + 2;

    // Draw minor grid lines
    ctx.lineWidth = 1; ctx.globalAlpha = 0.55; ctx.strokeStyle = '#222';
    for(let x=left;x<=right;x++){
      const sx = Math.round(worldToScreen(x,0).x)+0.5;
      ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,h); ctx.stroke();
    }
    for(let y=bottom;y<=top;y++){
      const sy = Math.round(worldToScreen(0,y).y)+0.5;
      ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(w,sy); ctx.stroke();
    }

    // Draw X and Y axes thicker
    ctx.globalAlpha = 1; ctx.lineWidth = 1.8; ctx.strokeStyle = '#000';
    const axisX = Math.round(worldToScreen(0,0).x)+0.5; ctx.beginPath(); ctx.moveTo(axisX,0); ctx.lineTo(axisX,h); ctx.stroke();
    const axisY = Math.round(worldToScreen(0,0).y)+0.5; ctx.beginPath(); ctx.moveTo(0,axisY); ctx.lineTo(w,axisY); ctx.stroke();
  }

  // drawColoredPolygon(points, color): provided drawing function
  function drawColoredPolygon(points, color="#808080") {
    if (points.length < 3) return; // need at least a triangle

    // Convert all world points to screen coordinates
    const screenPoints = points.map(([wx, wy]) => worldToScreen(wx, wy));

    ctx.save();
    ctx.beginPath();

    // Move to the first point
    ctx.moveTo(screenPoints[0].x, screenPoints[0].y);
    // Draw lines between all points
    for (let i = 1; i < screenPoints.length; i++) {
      ctx.lineTo(screenPoints[i].x, screenPoints[i].y);
    }
    // Close the shape
    ctx.closePath();

    // Fill (transparent)
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = color;
    ctx.fill();

    // Stroke (thicker and slightly less transparent)
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 4 * scale; // scales with zoom
    ctx.strokeStyle = color;
    ctx.stroke();

    ctx.restore();
  }



  // === SHAPE DRAWING HELPERS ===
  function drawShapeAtWorld(x,y,size,shape,color,fill=true){
    const p = worldToScreen(x,y);
    drawShapeAtScreen(p.x,p.y,size*baseGridPx*scale,shape,color,fill);
  }
  function drawShapeAtScreen(cx, cy, pxSize, shape, color, fill = true) {
    const r = pxSize / 2;
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(1, pxSize * 0.08);

    // Helper to draw regular polygons
    const drawPolygon = (sides, rotation = -Math.PI / 2) => {
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = rotation + (i * 2 * Math.PI) / sides;
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      fill ? ctx.fill() : ctx.stroke();
    };

    switch (shape) {
      case 'circle':
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        fill ? ctx.fill() : ctx.stroke();
        break;

      case 'square':
        ctx.rect(cx - r, cy - r, 2 * r, 2 * r);
        fill ? ctx.fill() : ctx.stroke();
        break;

      case 'triangle':
        drawPolygon(3);
        break;

      case 'pentagon':
        drawPolygon(5);
        break;

      case 'hexagon':
        drawPolygon(6);
        break;

      case 'octagon':
        drawPolygon(8);
        break;

      case 'star': {
        const spikes = 5;
        const outerRadius = r;
        const innerRadius = r * 0.5;
        let rot = -Math.PI / 2;
        ctx.beginPath();
        for (let i = 0; i < spikes; i++) {
          const xOuter = cx + Math.cos(rot) * outerRadius;
          const yOuter = cy + Math.sin(rot) * outerRadius;
          ctx.lineTo(xOuter, yOuter);
          rot += Math.PI / spikes;
          const xInner = cx + Math.cos(rot) * innerRadius;
          const yInner = cy + Math.sin(rot) * innerRadius;
          ctx.lineTo(xInner, yInner);
          rot += Math.PI / spikes;
        }
        ctx.closePath();
        fill ? ctx.fill() : ctx.stroke();
        break;
      }

      case 'cross': {
        const arm = r * 1;
        const t = r * 0.35;
        ctx.beginPath();
        ctx.moveTo(cx - t, cy - arm);
        ctx.lineTo(cx + t, cy - arm);
        ctx.lineTo(cx + t, cy - t);
        ctx.lineTo(cx + arm, cy - t);
        ctx.lineTo(cx + arm, cy + t);
        ctx.lineTo(cx + t, cy + t);
        ctx.lineTo(cx + t, cy + arm);
        ctx.lineTo(cx - t, cy + arm);
        ctx.lineTo(cx - t, cy + t);
        ctx.lineTo(cx - arm, cy + t);
        ctx.lineTo(cx - arm, cy - t);
        ctx.lineTo(cx - t, cy - t);
        ctx.closePath();
        fill ? ctx.fill() : ctx.stroke();
        break;
      }

      default:
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        fill ? ctx.fill() : ctx.stroke();
        break;
    }
  }

  // === MAIN DRAW LOOP ===
  function drawAll(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    drawGrid();

    // Draw all placed points
    for(const b of placedBalls){ drawShapeAtWorld(b.x,b.y,size,b.shape,b.color,true); }

    // Draw hovered preview if empty position
    const occupied = placedBalls.some(b=>b.x===hoverSnap.x && b.y===hoverSnap.y);
    //preview point
    if(!occupied) drawShapeAtWorld(hoverSnap.x,hoverSnap.y,size,players[currentPlayer].shape,players[currentPlayer].color,false);
    if (enclosures.length > 0){
      enclosures.forEach(element => {
        drawColoredPolygon(element[0],players[element[1]].color);
      });
    };

  }

  // === GAME LOOP ===
  let last = performance.now();
  function loop(now){
    const dt = (now-last)/1000; last = now;

    // Handle camera keyboard movement
    let dx=0,dy=0;
    if(keys['ArrowLeft']||keys['a']) dx-=1;
    if(keys['ArrowRight']||keys['d']) dx+=1;
    if(keys['ArrowUp']||keys['w']) dy+=1;
    if(keys['ArrowDown']||keys['s']) dy-=1;
    if(dx||dy){ const len = Math.hypot(dx,dy)||1;
    camera.x += (dx/len)*speedUnitsPerSecond*dt;
    camera.y += (dy/len)*speedUnitsPerSecond*dt; }

    drawAll();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // === INPUT HANDLERS ===

  window.addEventListener('keydown', e=>{
    if(e.ctrlKey && e.key.toLowerCase()==='z'){ undo(); e.preventDefault(); return; }
    if(e.ctrlKey && e.key.toLowerCase()==='y'){ redo(); e.preventDefault(); return; }
    if(e.key === '+'){ zoomAt(canvas.clientWidth/2,canvas.clientHeight/2,1.15); e.preventDefault(); }
    if(e.key === '-') { zoomAt(canvas.clientWidth/2,canvas.clientHeight/2,1/1.15); e.preventDefault(); }
    if(e.key.toLowerCase()==='r'){ resetView(); e.preventDefault(); }
    keys[e.key] = true;
  });
  window.addEventListener('keyup', e=>{ keys[e.key]=false; });

  // === ZOOM & PAN ===
  canvas.addEventListener('wheel', e=>{
    const delta = -e.deltaY;
    const factor = delta>0?1.08:1/1.08;
    zoomAt(e.offsetX,e.offsetY,factor);
    e.preventDefault();
  },{passive:false});

  function zoomAt(sx,sy,factor){
    const before = screenToWorld(sx,sy);
    scale *= factor; scale = Math.max(0.08,Math.min(8,scale));
    const after = screenToWorld(sx,sy);
    camera.x += before.x - after.x;
    camera.y += before.y - after.y;
  }

  function resetView(){ scale=1; camera.x=0; camera.y=0; }

  // === MOUSE EVENTS ===
  canvas.tabIndex = 0; canvas.style.outline='none';
  canvas.addEventListener('contextmenu', e=>{ e.preventDefault(); });

  canvas.addEventListener('mousedown', e=>{
    // Right mouse: start panning
    if(e.button===2){ isPanning=true; panLast={x:e.clientX,y:e.clientY}; return; }

    // Left mouse: attempt to place a point
    if(e.button===0){ const world = screenToWorld(e.offsetX,e.offsetY); placeAt(world); }
  });

  // Update hover position & handle camera drag
  window.addEventListener('mousemove', e=>{
    if(isPanning && panLast){
      const dx = (e.clientX - panLast.x)/(baseGridPx*scale);
      const dy = (e.clientY - panLast.y)/(baseGridPx*scale);
      camera.x -= dx; camera.y += dy; panLast={x:e.clientX,y:e.clientY};
    }
    const w = screenToWorld(e.offsetX,e.offsetY);
    hoverSnap.x = Math.round(w.x); hoverSnap.y = Math.round(w.y);
    coordBox.textContent = `x: ${w.x.toFixed(2)}, y: ${w.y.toFixed(2)}, zoom: ${scale.toFixed(2)}`;
  });

  window.addEventListener('mouseup', e=>{ if(e.button===2){ isPanning=false; panLast=null; } });

  // === GAME LOGIC: PLACE, UNDO, REDO ===
  

  //calculates if you captured something (instrumented with debug logs)
  function detectCapture() {
    console.log('--- detectCapture START ---');
    if (placedBalls.length < 6) { console.log('Too few balls placed:', placedBalls.length); return null; }

    const lastPlaced = placedBalls[placedBalls.length - 1];
    console.log('Last placed:', lastPlaced);
    const playerId = lastPlaced.player; // numeric player id as stored on ball
    const color = lastPlaced.color;

    const key = (x, y) => `${x},${y}`;

    // map of alive balls by position
    const pos2ball = new Map();
    for (const b of placedBalls) if (b.alive) pos2ball.set(key(b.x, b.y), b);
    console.log('Alive balls map size:', pos2ball.size);

    // quick list of same-color alive nodes
    const sameColor = placedBalls.filter(p => p.alive && p.color === color).map(p => [p.x, p.y]);
    console.log('Same-color alive nodes:', sameColor);
    if (sameColor.length < 4) { console.log('Not enough same-color stones for enclosure:', sameColor.length); return null; }

    const nodeSet = new Set(sameColor.map(([x, y]) => key(x, y)));

    // helper checks
    function checkValidity(x, y, pid) {
      const k = key(x, y);
      const pt = pos2ball.get(k);
      const res = !!pt && pt.player === pid && pt.alive;
      console.log(`checkValidity(${x},${y},pid=${pid}) ->`, res, 'point=', pt);
      return res;
    }
    function isEmpty(x, y) { const e = !pos2ball.has(key(x, y)); console.log(`isEmpty(${x},${y}) ->`, e); return e; }

    // direction vectors (codes 1..16)
    const dirVec = {
      1: [1, 1],   2: [1, -1], 3: [-1, -1], 4: [-1, 1],
      5: [1, 0],   6: [0, 1],  7: [-1, 0],  8: [0, -1],
      9: [2, 0],  10: [0, 2], 11: [-2, 0], 12: [0, -2],
      13: [1, 0], 14: [0, 1], 15: [-1, 0], 16: [0, -1]
    };

    // allowed next directions per your spec
    const allowedNext = {
      1: [4, 6, 1, 5, 2],
      2: [1, 5, 2, 8, 4],
      3: [4, 7, 3, 8, 2],
      4: [1, 3, 6, 4, 7],
      5: [1, 5, 2],
      6: [1, 6, 4],
      7: [4, 7, 3],
      8: [2, 8, 3],
      9: [13],
      10: [14],
      11: [15],
      12: [16],
      13: [6, 1, 5, 2, 8],
      14: [5, 1, 6, 4, 7],
      15: [8, 4, 7, 3, 6],
      16: [7, 2, 8, 3, 5]
    };

    // mapping for jump intermediary: when cardinal 5..8 finds empty immediate cell, we try intermediate 9..12
    const toIntermediary = { 5: 9, 6: 10, 7: 11, 8: 12 };
    // mapping from intermediary (9..12) to post-jump codes (13..16)
    const interToPost = { 9: 13, 10: 14, 11: 15, 12: 16 };
    // mapping post-jump back to canonical cardinal parent (for clarity)
    const postToCardinal = { 13: 5, 14: 6, 15: 7, 16: 8 };

    // normalize cycle to canonical string to dedupe
    function normalizeCycle(cycle) {
      const n = cycle.length;
      const variants = [];
      for (let i = 0; i < n; i++) {
        const rot = [];
        for (let j = 0; j < n; j++) rot.push(cycle[(i + j) % n]);
        variants.push(rot);
      }
      const rev = variants.map(v => [...v].reverse());
      const all = variants.concat(rev);
      const strs = all.map(v => v.map(([x,y]) => `${x},${y}`).join('|'));
      return strs.reduce((a,b) => (a < b ? a : b));
    }

    // iterative propagation stack
    const origin = [lastPlaced.x, lastPlaced.y];
    const originKey = key(...origin);
    const maxPath = 100;

    const cyclesSet = new Set();
    const cycles = [];

    const stack = [];

    console.log('Initializing stack from origin', origin);
    // push initial directions from origin (origin can try all 1..8)
    for (let dir = 1; dir <= 8; dir++) {
      const [dx, dy] = dirVec[dir];
      const nx = origin[0] + dx, ny = origin[1] + dy;
      console.log('Origin trying dir', dir, '->', nx, ny);
      if (checkValidity(nx, ny, playerId)) {
        console.log(' -> valid neighbor, pushing path', [[...origin], [nx, ny]], 'dir', dir);
        stack.push({ path: [[...origin], [nx, ny]], dir });
      } else if ((dir >= 5 && dir <= 8) && isEmpty(nx, ny)) {
        // try intermediary double-step from origin
        const dx2 = dx * 2, dy2 = dy * 2;
        const jx = origin[0] + dx2, jy = origin[1] + dy2;
        console.log(' -> immediate empty, trying jump to', jx, jy);
        if (checkValidity(jx, jy, playerId)) {
          const inter = toIntermediary[dir];
          const post = interToPost[inter];
          console.log(' -> jump valid, pushing path', [[...origin], [jx, jy]], 'intermediate dir', inter, 'post->', post);
          // set dir to post-jump (13..16) to continue from that landed cell
          stack.push({ path: [[...origin], [jx, jy]], dir: post });
        }
      }
    }

    console.log('Initial stack size:', stack.length);

    // Explore iteratively
    while (stack.length) {
      const node = stack.pop();
      const path = node.path;
      const cur = path[path.length - 1];
      const curKey = key(...cur);

      console.log('Popped node. Path length:', path.length, 'Path:', path, 'dir:', node.dir);

      if (path.length > maxPath) { console.log('Path too long, skipping'); continue; }

      const dir = node.dir;
      const nextDirs = allowedNext[dir] || [];

      for (const nd of nextDirs) {
        // compute basic step vector for nd (if nd is 9..12 or 13..16 this vector exists in dirVec)
        const vec = dirVec[nd];
        if (!vec) { console.log(' No vector for nd', nd); continue; }
        let tx = cur[0] + vec[0], ty = cur[1] + vec[1];

        console.log(' Considering nd', nd, '-> target', tx, ty, '(from cur', cur, ')');

        // If nd is 13..16 (post-jump) we already landed after a jump and should use normal neighbor handling
        // If nd is 5..8 (cardinal) and immediate cell is empty from cur, attempt intermediary jump to 9..12 -> post
        if (nd >= 5 && nd <= 8) {
          // immediate target tx,ty is the adjacent cell in that cardinal direction
          if (isEmpty(tx, ty)) {
            // attempt jump to double cell
            const inter = toIntermediary[nd];       // 9..12
            const post = interToPost[inter];       // 13..16
            const dx2 = dirVec[inter][0], dy2 = dirVec[inter][1];
            const jx = cur[0] + dx2, jy = cur[1] + dy2;
            console.log('  Immediate cell empty, considering jump to', jx, jy, 'intermediate', inter, 'post->', post);
            if (checkValidity(jx, jy, playerId)) {
              // check if we formed cycle with jump target
              const alreadyIndex = path.findIndex(([x,y]) => x===jx && y===jy);
              if (alreadyIndex !== -1) {
                const cyc = path.slice(alreadyIndex);
                console.log('  Found cycle via jump:', cyc);
                if (cyc.length >= 4) {
                  const norm = normalizeCycle(cyc);
                  if (!cyclesSet.has(norm)) { cyclesSet.add(norm); cycles.push(cyc); console.log('   -> Added normalized cycle', norm); }
                }
              } else {
                const prev = path.length >=2 ? path[path.length-2] : null;
                if (prev && prev[0] === jx && prev[1] === jy) { console.log('  Jump would backtrack to parent, skipping jump'); }
                else {
                  console.log('  Pushing jump to stack:', jx, jy, 'with post-dir', post);
                  stack.push({ path: [...path, [jx, jy]], dir: post });
                }
              }
            } else {
              console.log('  Jump target invalid or not same-color/alive');
            }
            // do not try moving into the empty immediate cell as a normal neighbor
            continue;
          }
        }

        // For intermediaries nd in 9..12 (if ever encountered directly), interpret as a jump target already:
        // handled by checking validity below (tx,ty will be double-step cell)
        // For all cases, perform validity check
        if (checkValidity(tx, ty, playerId)) {
          const alreadyIndex = path.findIndex(([x,y]) => x===tx && y===ty);
          if (alreadyIndex !== -1) {
            // cycle found
            const cyc = path.slice(alreadyIndex);
            console.log('  Found cycle via normal neighbor:', cyc);
            if (cyc.length >= 4) {
              const norm = normalizeCycle(cyc);
              if (!cyclesSet.has(norm)) { cyclesSet.add(norm); cycles.push(cyc); console.log('   -> Added normalized cycle', norm); }
            }
          } else {
            // avoid immediate backtrack to parent
            const prev = path.length >=2 ? path[path.length-2] : null;
            if (prev && prev[0] === tx && prev[1] === ty) { console.log('  Would backtrack to parent, skipping'); continue; }

            // If nd is intermediary (9..12) we should continue using the corresponding post-jump code
            let pushDir = nd;
            if (nd >= 9 && nd <= 12) { pushDir = interToPost[nd]; }

            // If nd is post-jump 13..16, we may want to use its mapped allowedNext already (we are already doing so)
            console.log('  Pushing neighbor to stack:', tx, ty, 'dir->', pushDir);
            stack.push({ path: [...path, [tx, ty]], dir: pushDir });
          }
        } else {
          console.log('  Neighbor invalid:', tx, ty);
        }
      } // end for nextDirs
    } // end while stack

    console.log('Finished exploration. Cycles found:', cycles.length);
    if (cycles.length === 0) { console.log('No cycles -> no capture'); return null; }

    // point-in-polygon test (same as before)
    function pointInPoly(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const [xi, yi] = poly[i];
        const [xj, yj] = poly[j];
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // For each cycle get enemies inside
    let totalCaptured = 0;
    for (const cyc of cycles) {
      console.log('Processing cycle:', cyc);
      const wallsSet = new Set(cyc.map(([x,y]) => key(x,y)));
      const xs = cyc.map(p => p[0]), ys = cyc.map(p => p[1]);
      const minX = Math.min(...xs) - 1, maxX = Math.max(...xs) + 1;
      const minY = Math.min(...ys) - 1, maxY = Math.max(...ys) + 1;
      const enemies = [];
      const empties = [];
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const k = key(x, y);
          if (wallsSet.has(k)) continue;
          if (pointInPoly(x, y, cyc)) {
            const ball = pos2ball.get(k);
            if (ball) {
              if (ball.player !== playerId && ball.alive) enemies.push([x, y]);
            } else {
              empties.push([x, y]);
            }
          }
        }
      }

      console.log(' enemies found in cycle:', enemies, 'empties:', empties.length);

      if (enemies.length === 0) { console.log(' No enemies inside, skipping cycle'); continue; }

      // mark captured
      for (const [ex, ey] of enemies) {
        for (const b of placedBalls) {
          if (b.x === ex && b.y === ey && b.alive) {
            console.log(' Capturing ball at', ex, ey, b);
            b.alive = false;
            // award score to current player
            players[playerId].score = (players[playerId].score || 0) + 1;
            totalCaptured++;
          }
        }
      }

      // add empties to deadspace
      for (const pt of empties) if (!deadspace.some(([x,y]) => x===pt[0] && y===pt[1])) {
        console.log(' Adding empty inside to deadspace', pt);
        deadspace.push(pt);
      }

      // register enclosure and draw polygon
      console.log(' Registering enclosure and drawing polygon for player', playerId);
      enclosures.push([cyc, playerId]);
      drawColoredPolygon(cyc, players[playerId].color);
    }

    console.log('Total captured this move:', totalCaptured);
    console.log('--- detectCapture END ---');
    return totalCaptured > 0 ? { captured: totalCaptured, cycles } : null;
  }



  function updateCurrentPlayer(){
    currentPlayer = currentPlayerIndex();
    nextPlayere = currentPlayerIndex(1);
  }
function placeAt(world){

  updateCurrentPlayer()






    
    const sx = Math.round(world.x);
    const sy = Math.round(world.y);

    // Prevent placing on occupied grid and deadSpace point
    if (
      placedBalls.some(b => b.x === sx && b.y === sy) ||
      deadspace.some(d => d[0] === sx && d[1] === sy)
    ) return;


    //set point onn board
    const ball = {x:sx,y:sy,player:currentPlayer,color:players[currentPlayer].color,shape:players[currentPlayer].shape,alive: true};
    placedBalls.push(ball);
    const captures = detectCapture();
    console.log(JSON.stringify(captures, null, 2));
    // Save move to undo history
    undoStack.push({type:'add',ball}); redoStack.length=0;
    
    counter++
    updateCurrentPlayer()

    // Switch player turn
    nextPlayer = nextPlayer===1?2:1;
    
  }

  function undo(){
    if(undoStack.length===0) return;
    const action = undoStack.pop();
    if(action.type==='add'){
      for(let i=placedBalls.length-1;i>=0;i--){
        const b=placedBalls[i];
        if(b.x===action.ball.x && b.y===action.ball.y && b.player===action.ball.player){
          placedBalls.splice(i,1);
          redoStack.push(action);
          counter-=1
          updateCurrentPlayer()
          break;
        }
      }
    }
    print
  }

  function redo(){
    if(redoStack.length===0) return;
    const action = redoStack.pop();
    if(action.type==='add'){
      placedBalls.push(action.ball);
      undoStack.push(action);
      counter++
      updateCurrentPlayer()
    }
    
  }


  // Counter logic

  function currentPlayerIndex(extra=0){ return ((counter+extra) % playerCount); } // 0-based index into players array
  //function currentPlayer(){ return players[currentPlayerIndex()]; }





  // === MODAL INTERACTIONS ===
  infoBtn.addEventListener('click', ()=>{ popup.style.display='flex'; });
  closeInfo.addEventListener('click', ()=>{ popup.style.display='none'; });
  popup.addEventListener('click', e=>{ if(e.target===popup) popup.style.display='none'; });
})();
</script>
</body>
</html>

