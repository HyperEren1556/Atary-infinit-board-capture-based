<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Grid — Snap, Shapes</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden}
    canvas{display:block;width:100%;height:100%;background:#ffffff;touch-action:none}
    #controls {
      position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:20
    }
    .btn {
      width:40px;height:40px;display:flex;align-items:center;justify-content:center;background:#fff;border:1px solid #ccc;border-radius:8px;cursor:pointer;font-size:18px;box-shadow:0 3px 8px rgba(0,0,0,0.08);user-select:none
    }

    #popup {
      position:fixed;inset:0;background:rgba(0,0,0,0.35);display:none;align-items:center;justify-content:center;z-index:30;
    }
    .modal {
      background:#fff;padding:18px;border-radius:10px;max-width:520px;width:90%;box-shadow:0 8px 30px rgba(0,0,0,0.2);position:relative;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#111;
    }
    .modal h2{margin:0 0 8px 0}
    .closeX{position:absolute;right:12px;top:8px;cursor:pointer;font-size:20px}
    #errToast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#fff;padding:8px 12px;border-radius:8px;border:1px solid #f44336;color:#f44336;display:none;z-index:60}
    #coordBox{position:fixed;right:12px;bottom:12px;padding:6px 8px;background:rgba(255,255,255,0.9);border:1px solid #eee;border-radius:8px;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;font-size:13px}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="controls">
    <div id="infoBtn" class="btn">ℹ️</div>
  </div>

  <!-- Info Modal -->
  <div id="popup"><div class="modal" id="infoModal">
    <div id="closeInfo" class="closeX">❌</div>
    <h2>Controls & Instructions</h2>
    <div>
      <ul>
        <li>Left click / tap: place a point (snaps to nearest grid intersection)</li>
        <li>Alternating players: Player 1 then Player 2, continuously</li>
        <li>Can't place where a ball already exists</li>
        <li>Right-click + drag or touch swipe: pan the grid</li>
        <li>Mouse wheel or + / - keys: zoom (balls scale with zoom)</li>
        <li>Ctrl+Z: Undo, Ctrl+Y: Redo</li>
        <li>R: Reset view</li>
      </ul>
    </div>
  </div></div>

  <div id="errToast">Importing error.</div>
  <div id="coordBox">x: 0.00, y: 0.00, zoom: 1.00</div>

<script>


        
(() => {
  // === CANVAS & CONTEXT INITIALIZATION ===
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // === UI ELEMENT REFERENCES ===
  const infoBtn = document.getElementById('infoBtn');
  const popup = document.getElementById('popup');
  const closeInfo = document.getElementById('closeInfo');
  const errToast = document.getElementById('errToast');
  const coordBox = document.getElementById('coordBox');

  // === RESPONSIVE RESIZING FUNCTION ===
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // === GRID CONFIGURATION ===
  const baseGridPx = 40; // each grid unit equals 40 pixels
  let scale = 1.0; // zoom scale
  let camera = { x: 0, y: 0 }; // camera center in world coordinates
  let size = 0.5

  // === GAME STATE VARIABLES ===
  let counter = 0; // increases each time a point is placed (or when a captured-shape is saved as one move)
  const keys = {}; // keyboard state
  const speedUnitsPerSecond = 6; // camera pan speed
  const placedBalls = []; // all placed grid points
  const deadspace = []; //captured empty space, to prevent placing new points
  const enclosures = [];
  let nextPlayer = 1; // 1 or 2, determines next turn
  const undoStack = []; // history of moves for undo
  const redoStack = []; // history of undone moves for redo
  let hoverSnap = {x:0,y:0}; // hovered grid position (snapped)
  let isPanning = false; // panning flag
  let panLast = null; // last pan mouse position
  
  //scores
  let p1Score = 0
  let p2Score = 0
  let p3Score = 0
  let p4Score = 0

  // === PLAYER SETTINGS ===
  const settingsState = {
    p1: { color: '#ff0000', shape: 'circle' },
    p2: { color: '#3b82f6', shape: 'square' },
    p3: { color: '#00ff00', shape: 'triangle' },
    p4: { color: '#ffed29', shape: 'pentagon' }
  };

  // === COORDINATE CONVERSION FUNCTIONS ===
  function worldToScreen(wx, wy){
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    return { x: cx + (wx - camera.x) * baseGridPx * scale, y: cy - (wy - camera.y) * baseGridPx * scale };
  }
  function screenToWorld(sx, sy){
    const cx = canvas.clientWidth/2;
    const cy = canvas.clientHeight/2;
    return { x: camera.x + (sx - cx) / (baseGridPx * scale), y: camera.y - (sy - cy) / (baseGridPx * scale) };
  }

  // === DRAWING GRID ===
  function drawGrid(){
    const w = canvas.clientWidth; const h = canvas.clientHeight;
    const halfWUnits = (w/2) / (baseGridPx * scale);
    const halfHUnits = (h/2) / (baseGridPx * scale);
    const left = Math.floor(camera.x - halfWUnits) - 2;
    const right = Math.ceil(camera.x + halfWUnits) + 2;
    const bottom = Math.floor(camera.y - halfHUnits) - 2;
    const top = Math.ceil(camera.y + halfHUnits) + 2;

    // Draw minor grid lines
    ctx.lineWidth = 1; ctx.globalAlpha = 0.55; ctx.strokeStyle = '#222';
    for(let x=left;x<=right;x++){
      const sx = Math.round(worldToScreen(x,0).x)+0.5;
      ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,h); ctx.stroke();
    }
    for(let y=bottom;y<=top;y++){
      const sy = Math.round(worldToScreen(0,y).y)+0.5;
      ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(w,sy); ctx.stroke();
    }

    // Draw X and Y axes thicker
    ctx.globalAlpha = 1; ctx.lineWidth = 1.8; ctx.strokeStyle = '#000';
    const axisX = Math.round(worldToScreen(0,0).x)+0.5; ctx.beginPath(); ctx.moveTo(axisX,0); ctx.lineTo(axisX,h); ctx.stroke();
    const axisY = Math.round(worldToScreen(0,0).y)+0.5; ctx.beginPath(); ctx.moveTo(0,axisY); ctx.lineTo(w,axisY); ctx.stroke();
  }


  function drawColoredPolygon(points, color="#808080") {
    if (points.length < 3) return; // need at least a triangle

    // Convert all world points to screen coordinates
    const screenPoints = points.map(([wx, wy]) => worldToScreen(wx, wy));

    ctx.save();
    ctx.beginPath();

    // Move to the first point
    ctx.moveTo(screenPoints[0].x, screenPoints[0].y);
    // Draw lines between all points
    for (let i = 1; i < screenPoints.length; i++) {
      ctx.lineTo(screenPoints[i].x, screenPoints[i].y);
    }
    // Close the shape
    ctx.closePath();

    // Fill (transparent)
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = color;
    ctx.fill();

    // Stroke (thicker and slightly less transparent)
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 4 * scale; // scales with zoom
    ctx.strokeStyle = color;
    ctx.stroke();

    ctx.restore();
  }



  // === SHAPE DRAWING HELPERS ===
  function drawShapeAtWorld(x,y,size,shape,color,fill=true){
    const p = worldToScreen(x,y);
    drawShapeAtScreen(p.x,p.y,size*baseGridPx*scale,shape,color,fill);
  }
  function drawShapeAtScreen(cx, cy, pxSize, shape, color, fill = true) {
    const r = pxSize / 2;
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(1, pxSize * 0.08);

    // Helper to draw regular polygons
    const drawPolygon = (sides, rotation = -Math.PI / 2) => {
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = rotation + (i * 2 * Math.PI) / sides;
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      fill ? ctx.fill() : ctx.stroke();
    };

    switch (shape) {
      case 'circle':
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        fill ? ctx.fill() : ctx.stroke();
        break;

      case 'square':
        ctx.rect(cx - r, cy - r, 2 * r, 2 * r);
        fill ? ctx.fill() : ctx.stroke();
        break;

      case 'triangle':
        drawPolygon(3);
        break;

      case 'pentagon':
        drawPolygon(5);
        break;

      case 'hexagon':
        drawPolygon(6);
        break;

      case 'octagon':
        drawPolygon(8);
        break;

      case 'star': {
        const spikes = 5;
        const outerRadius = r;
        const innerRadius = r * 0.5;
        let rot = -Math.PI / 2;
        ctx.beginPath();
        for (let i = 0; i < spikes; i++) {
          const xOuter = cx + Math.cos(rot) * outerRadius;
          const yOuter = cy + Math.sin(rot) * outerRadius;
          ctx.lineTo(xOuter, yOuter);
          rot += Math.PI / spikes;
          const xInner = cx + Math.cos(rot) * innerRadius;
          const yInner = cy + Math.sin(rot) * innerRadius;
          ctx.lineTo(xInner, yInner);
          rot += Math.PI / spikes;
        }
        ctx.closePath();
        fill ? ctx.fill() : ctx.stroke();
        break;
      }

      case 'cross': {
        const arm = r * 1;
        const t = r * 0.35;
        ctx.beginPath();
        ctx.moveTo(cx - t, cy - arm);
        ctx.lineTo(cx + t, cy - arm);
        ctx.lineTo(cx + t, cy - t);
        ctx.lineTo(cx + arm, cy - t);
        ctx.lineTo(cx + arm, cy + t);
        ctx.lineTo(cx + t, cy + t);
        ctx.lineTo(cx + t, cy + arm);
        ctx.lineTo(cx - t, cy + arm);
        ctx.lineTo(cx - t, cy + t);
        ctx.lineTo(cx - arm, cy + t);
        ctx.lineTo(cx - arm, cy - t);
        ctx.lineTo(cx - t, cy - t);
        ctx.closePath();
        fill ? ctx.fill() : ctx.stroke();
        break;
      }

      default:
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        fill ? ctx.fill() : ctx.stroke();
        break;
    }
  }

  // === MAIN DRAW LOOP ===
  function drawAll(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    drawGrid();

    // Draw all placed points
    for(const b of placedBalls){ drawShapeAtWorld(b.x,b.y,size,b.shape,b.color,true); }

    // Draw hovered preview if empty position
    const occupied = placedBalls.some(b=>b.x===hoverSnap.x && b.y===hoverSnap.y);
    const pref = nextPlayer===1 ? settingsState.p1 : settingsState.p2;
    if(!occupied) drawShapeAtWorld(hoverSnap.x,hoverSnap.y,size,pref.shape,pref.color,false);
    if (enclosures.length > 0){
      enclosures.forEach(element => {
        drawColoredPolygon(element[0],settingsState['p' + element[1]].color);
      });
    };

  }

  // === GAME LOOP ===
  let last = performance.now();
  function loop(now){
    const dt = (now-last)/1000; last = now;

    // Handle camera keyboard movement
    let dx=0,dy=0;
    if(keys['ArrowLeft']||keys['a']) dx-=1;
    if(keys['ArrowRight']||keys['d']) dx+=1;
    if(keys['ArrowUp']||keys['w']) dy+=1;
    if(keys['ArrowDown']||keys['s']) dy-=1;
    if(dx||dy){ const len = Math.hypot(dx,dy)||1;
    camera.x += (dx/len)*speedUnitsPerSecond*dt;
    camera.y += (dy/len)*speedUnitsPerSecond*dt; }

    drawAll();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // === INPUT HANDLERS ===

  window.addEventListener('keydown', e=>{
    if(e.ctrlKey && e.key.toLowerCase()==='z'){ undo(); e.preventDefault(); return; }
    if(e.ctrlKey && e.key.toLowerCase()==='y'){ redo(); e.preventDefault(); return; }
    if(e.key === '+'){ zoomAt(canvas.clientWidth/2,canvas.clientHeight/2,1.15); e.preventDefault(); }
    if(e.key === '-') { zoomAt(canvas.clientWidth/2,canvas.clientHeight/2,1/1.15); e.preventDefault(); }
    if(e.key.toLowerCase()==='r'){ resetView(); e.preventDefault(); }
    keys[e.key] = true;
  });
  window.addEventListener('keyup', e=>{ keys[e.key]=false; });

  // === ZOOM & PAN ===
  canvas.addEventListener('wheel', e=>{
    const delta = -e.deltaY;
    const factor = delta>0?1.08:1/1.08;
    zoomAt(e.offsetX,e.offsetY,factor);
    e.preventDefault();
  },{passive:false});

  function zoomAt(sx,sy,factor){
    const before = screenToWorld(sx,sy);
    scale *= factor; scale = Math.max(0.08,Math.min(8,scale));
    const after = screenToWorld(sx,sy);
    camera.x += before.x - after.x;
    camera.y += before.y - after.y;
  }

  function resetView(){ scale=1; camera.x=0; camera.y=0; }

  // === MOUSE EVENTS ===
  canvas.tabIndex = 0; canvas.style.outline='none';
  canvas.addEventListener('contextmenu', e=>{ e.preventDefault(); });

  canvas.addEventListener('mousedown', e=>{
    // Right mouse: start panning
    if(e.button===2){ isPanning=true; panLast={x:e.clientX,y:e.clientY}; return; }

    // Left mouse: attempt to place a point
    if(e.button===0){ const world = screenToWorld(e.offsetX,e.offsetY); placeAt(world); }
  });

  // Update hover position & handle camera drag
  window.addEventListener('mousemove', e=>{
    if(isPanning && panLast){
      const dx = (e.clientX - panLast.x)/(baseGridPx*scale);
      const dy = (e.clientY - panLast.y)/(baseGridPx*scale);
      camera.x -= dx; camera.y += dy; panLast={x:e.clientX,y:e.clientY};
    }
    const w = screenToWorld(e.offsetX,e.offsetY);
    hoverSnap.x = Math.round(w.x); hoverSnap.y = Math.round(w.y);
    coordBox.textContent = `x: ${w.x.toFixed(2)}, y: ${w.y.toFixed(2)}, zoom: ${scale.toFixed(2)}`;
  });

  window.addEventListener('mouseup', e=>{ if(e.button===2){ isPanning=false; panLast=null; } });

  // === GAME LOGIC: PLACE, UNDO, REDO ===
  function placeAt(world){


// placedBalls: global array of all points
// deadspace: global array to collect enclosed empty coordinates
// drawColoredPolygon(points, color): provided drawing function



  function detectCapture() {
    if (placedBalls.length < 7) return null;

    const lastPlaced = placedBalls[placedBalls.length - 1];
    const color = lastPlaced.color;
    const player = lastPlaced.player;

    const key = (x, y) => `${x},${y}`;
    const parseKey = k => k.split(',').map(Number);

    // Map of alive points only
    const pos2ball = new Map();
    for (const b of placedBalls) {
      if (b.alive) pos2ball.set(key(b.x, b.y), b);
    }

    // connection rule
    function isConnected(a, b) {
      const dx = a[0] - b[0], dy = a[1] - b[1];
      if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) return true;
      if (Math.abs(dx) === 2 && dy === 0) {
        const mx = (a[0] + b[0]) / 2, my = (a[1] + b[1]) / 2;
        return !pos2ball.has(key(mx, my));
      }
      if (Math.abs(dy) === 2 && dx === 0) {
        const mx = (a[0] + b[0]) / 2, my = (a[1] + b[1]) / 2;
        return !pos2ball.has(key(mx, my));
      }
      return false;
    }

    // same-color and alive nodes
    const sameColor = placedBalls
      .filter(p => p.alive && p.color === color)
      .map(p => [p.x, p.y]);
    const nodeSet = new Set(sameColor.map(([x,y]) => key(x,y)));

    // adjacency
    const adj = new Map();
    for (const a of sameColor) {
      const kA = key(a[0], a[1]);
      const neigh = [];
      for (const b of sameColor) {
        if (a === b) continue;
        if (isConnected(a, b)) neigh.push(b);
      }
      adj.set(kA, neigh);
    }

    // normalize cycles
    function normalizeCycle(cycle) {
      const n = cycle.length;
      const variants = [];
      for (let i = 0; i < n; i++) {
        const rot = [];
        for (let j = 0; j < n; j++) rot.push(cycle[(i + j) % n]);
        variants.push(rot);
      }
      const rev = variants.map(v => [...v].reverse());
      const all = variants.concat(rev);
      const strs = all.map(v => v.map(([x,y]) => `${x},${y}`).join('|'));
      return strs.reduce((a,b) => (a < b ? a : b));
    }

    const start = [lastPlaced.x, lastPlaced.y];
    const startKey = key(...start);
    const cyclesSet = new Set();
    const cycles = [];

    function dfs(path) {
      const cur = path[path.length - 1];
      const curKey = key(...cur);
      const neighbors = adj.get(curKey) || [];
      for (const nb of neighbors) {
        const nbKey = key(...nb);
        // avoid backtrack
        if (path.length >= 2) {
          const prev = path[path.length - 2];
          if (nb[0] === prev[0] && nb[1] === prev[1]) continue;
        }
        const idx = path.findIndex(([x,y]) => x === nb[0] && y === nb[1]);
        if (idx !== -1) {
          const cyc = path.slice(idx);
          if (cyc.length >= 4) {
            const norm = normalizeCycle(cyc);
            if (!cyclesSet.has(norm)) {
              cyclesSet.add(norm);
              cycles.push(cyc);
            }
          }
          continue;
        }
        if (path.length > 40) continue;
        dfs([...path, nb]);
      }
    }

    if (nodeSet.has(startKey)) dfs([start]);
    if (cycles.length === 0) return null;

    // point in polygon
    function pointInPoly(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const [xi, yi] = poly[i];
        const [xj, yj] = poly[j];
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    let captureFound = false;

    for (const cyc of cycles) {
      const walls = cyc;
      const wallsSet = new Set(walls.map(([x,y]) => key(x,y)));

      const enemies = [];
      const empties = [];

      // bounding box
      const xs = cyc.map(p => p[0]), ys = cyc.map(p => p[1]);
      const minX = Math.min(...xs) - 1, maxX = Math.max(...xs) + 1;
      const minY = Math.min(...ys) - 1, maxY = Math.max(...ys) + 1;

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const k = key(x,y);
          if (wallsSet.has(k)) continue;
          if (pointInPoly(x, y, cyc)) {
            const ball = pos2ball.get(k);
            if (ball) {
              if (ball.color !== color && ball.alive) enemies.push([x,y]);
            } else {
              empties.push([x,y]);
            }
          }
        }
      }

      // only capture if there is at least one alive enemy inside
      if (enemies.length > 0) {
        captureFound = true;

        // mark captured as dead
        placedBalls.forEach(ball => {
          if (enemies.some(([x, y]) => ball.x === x && ball.y === y)) {
            ball.alive = false;
          }
        });

        // add empty inside points to deadspace
        empties.forEach(pt => {
          if (!deadspace.some(([x,y]) => x === pt[0] && y === pt[1])) {
            deadspace.push(pt);
          }
        });

        // register the capture walls
        enclosures.push([walls,player]);

        //add score

      }
    }

    return captureFound ? "captured" : null;
  }










    
    const sx = Math.round(world.x);
    const sy = Math.round(world.y);

    // Prevent placing on occupied grid and deadSpace point
    if (
      placedBalls.some(b => b.x === sx && b.y === sy) ||
      deadspace.some(d => d[0] === sx && d[1] === sy)
    ) return;

    const pref = nextPlayer===1 ? settingsState.p1 : settingsState.p2;
    const ball = {x:sx,y:sy,player:nextPlayer,color:pref.color,shape:pref.shape,alive: true};
    placedBalls.push(ball);
    const captures = detectCapture();
    console.log(JSON.stringify(captures, null, 2));
    console.log(enclosures)
    console.log(settingsState[`p1`])
    // Save move to undo history
    undoStack.push({type:'add',ball}); redoStack.length=0;

    // Switch player turn
    nextPlayer = nextPlayer===1?2:1;
  }

  function undo(){
    if(undoStack.length===0) return;
    const action = undoStack.pop();
    if(action.type==='add'){
      for(let i=placedBalls.length-1;i>=0;i--){
        const b=placedBalls[i];
        if(b.x===action.ball.x && b.y===action.ball.y && b.player===action.ball.player){
          placedBalls.splice(i,1);
          redoStack.push(action);
          break;
        }
      }
    }
  }

  function redo(){
    if(redoStack.length===0) return;
    const action = redoStack.pop();
    if(action.type==='add'){
      placedBalls.push(action.ball);
      undoStack.push(action);
    }
  }
  //to fix:

  //when double connection is formed, save the space in between in the deadspace
  //integrate the enclosure in the undo and redo function
  //fix the capture function: it creates a 2 lenght conection over the dead points
  //shotest possible way to create a capture?
  //or create a function that calculates if a line is already create then don't draw the line
  //or unite the polygons



  //fix the player switch, replace the curent function responsible for that, make sure you can add new players,
  //add the default setting array, change the name of settingState
  //edit all the variables player and currentPlayer in the code
  //use code from Dots-1

  //make sure player can't place on deadspace points, so put a control every time player tries to put a point, check if it's present in the list.
  

  //score display
  //count the the number of captured points(and ignore the deads) and then add it to the current player score
  //record in the history the enclosure, the captured points, the score added


  //wasd and arrow movement is scalled to the zoom quantity
  //add a score display on the top of the screen,
  //export
  //import
  //save
  //popups


  //DONE:
  //eliminate the manual capture botton and it's html,javascript and style fragments
  //make sure you can not put points in deadspace area



  // === MODAL INTERACTIONS ===
  infoBtn.addEventListener('click', ()=>{ popup.style.display='flex'; });
  closeInfo.addEventListener('click', ()=>{ popup.style.display='none'; });
  popup.addEventListener('click', e=>{ if(e.target===popup) popup.style.display='none'; });
})();
</script>
</body>
</html>

